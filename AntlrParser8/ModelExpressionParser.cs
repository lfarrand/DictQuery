//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.13.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from ModelExpression.g4 by ANTLR 4.13.2

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.13.2")]
[System.CLSCompliant(false)]
public partial class ModelExpressionParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		EQUALS=1, NOT_EQUALS=2, LESS_THAN=3, LESS_THAN_OR_EQUAL=4, GREATER_THAN=5, 
		GREATER_THAN_OR_EQUAL=6, PLUS=7, MINUS=8, MULTIPLY=9, DIVIDE=10, MODULO=11, 
		AND=12, OR=13, NOT=14, LIKE=15, IN=16, CONVERT=17, LEN=18, ISNULL=19, 
		IIF=20, TRIM=21, SUBSTRING=22, SUM=23, AVG=24, MIN=25, MAX=26, COUNT=27, 
		STDEV=28, VAR=29, PARENT=30, CHILD=31, NULL=32, IS=33, LPAREN=34, RPAREN=35, 
		LBRACKET=36, RBRACKET=37, BACKTICK=38, DOT=39, COMMA=40, HASH=41, STRING_LITERAL=42, 
		DATE_LITERAL=43, INTEGER_LITERAL=44, DECIMAL_LITERAL=45, BOOLEAN_LITERAL=46, 
		NULL_LITERAL=47, IDENTIFIER=48, BRACKETED_IDENTIFIER=49, WS=50;
	public const int
		RULE_expression = 0, RULE_orExpression = 1, RULE_andExpression = 2, RULE_notExpression = 3, 
		RULE_comparisonExpression = 4, RULE_inExpression = 5, RULE_additiveExpression = 6, 
		RULE_multiplicativeExpression = 7, RULE_unaryExpression = 8, RULE_primaryExpression = 9, 
		RULE_functionCall = 10, RULE_functionName = 11, RULE_argumentList = 12, 
		RULE_columnReference = 13, RULE_literal = 14;
	public static readonly string[] ruleNames = {
		"expression", "orExpression", "andExpression", "notExpression", "comparisonExpression", 
		"inExpression", "additiveExpression", "multiplicativeExpression", "unaryExpression", 
		"primaryExpression", "functionCall", "functionName", "argumentList", "columnReference", 
		"literal"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, "'<'", "'<='", "'>'", "'>='", "'+'", "'-'", "'*'", "'/'", 
		"'%'", null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, "'('", 
		"')'", "'['", "']'", "'`'", "'.'", "','", "'#'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "EQUALS", "NOT_EQUALS", "LESS_THAN", "LESS_THAN_OR_EQUAL", "GREATER_THAN", 
		"GREATER_THAN_OR_EQUAL", "PLUS", "MINUS", "MULTIPLY", "DIVIDE", "MODULO", 
		"AND", "OR", "NOT", "LIKE", "IN", "CONVERT", "LEN", "ISNULL", "IIF", "TRIM", 
		"SUBSTRING", "SUM", "AVG", "MIN", "MAX", "COUNT", "STDEV", "VAR", "PARENT", 
		"CHILD", "NULL", "IS", "LPAREN", "RPAREN", "LBRACKET", "RBRACKET", "BACKTICK", 
		"DOT", "COMMA", "HASH", "STRING_LITERAL", "DATE_LITERAL", "INTEGER_LITERAL", 
		"DECIMAL_LITERAL", "BOOLEAN_LITERAL", "NULL_LITERAL", "IDENTIFIER", "BRACKETED_IDENTIFIER", 
		"WS"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "ModelExpression.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static ModelExpressionParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public ModelExpressionParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public ModelExpressionParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class ExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public OrExpressionContext orExpression() {
			return GetRuleContext<OrExpressionContext>(0);
		}
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.EnterExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.ExitExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IModelExpressionVisitor<TResult> typedVisitor = visitor as IModelExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		ExpressionContext _localctx = new ExpressionContext(Context, State);
		EnterRule(_localctx, 0, RULE_expression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 30;
			orExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AndExpressionContext[] andExpression() {
			return GetRuleContexts<AndExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AndExpressionContext andExpression(int i) {
			return GetRuleContext<AndExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] OR() { return GetTokens(ModelExpressionParser.OR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR(int i) {
			return GetToken(ModelExpressionParser.OR, i);
		}
		public OrExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.EnterOrExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.ExitOrExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IModelExpressionVisitor<TResult> typedVisitor = visitor as IModelExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OrExpressionContext orExpression() {
		OrExpressionContext _localctx = new OrExpressionContext(Context, State);
		EnterRule(_localctx, 2, RULE_orExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 32;
			andExpression();
			State = 37;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==OR) {
				{
				{
				State = 33;
				Match(OR);
				State = 34;
				andExpression();
				}
				}
				State = 39;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AndExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NotExpressionContext[] notExpression() {
			return GetRuleContexts<NotExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public NotExpressionContext notExpression(int i) {
			return GetRuleContext<NotExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] AND() { return GetTokens(ModelExpressionParser.AND); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND(int i) {
			return GetToken(ModelExpressionParser.AND, i);
		}
		public AndExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_andExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.EnterAndExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.ExitAndExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IModelExpressionVisitor<TResult> typedVisitor = visitor as IModelExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAndExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AndExpressionContext andExpression() {
		AndExpressionContext _localctx = new AndExpressionContext(Context, State);
		EnterRule(_localctx, 4, RULE_andExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 40;
			notExpression();
			State = 45;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==AND) {
				{
				{
				State = 41;
				Match(AND);
				State = 42;
				notExpression();
				}
				}
				State = 47;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NotExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ComparisonExpressionContext comparisonExpression() {
			return GetRuleContext<ComparisonExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(ModelExpressionParser.NOT, 0); }
		public NotExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_notExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.EnterNotExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.ExitNotExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IModelExpressionVisitor<TResult> typedVisitor = visitor as IModelExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNotExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NotExpressionContext notExpression() {
		NotExpressionContext _localctx = new NotExpressionContext(Context, State);
		EnterRule(_localctx, 6, RULE_notExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 49;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 48;
				Match(NOT);
				}
			}

			State = 51;
			comparisonExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComparisonExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AdditiveExpressionContext[] additiveExpression() {
			return GetRuleContexts<AdditiveExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AdditiveExpressionContext additiveExpression(int i) {
			return GetRuleContext<AdditiveExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InExpressionContext inExpression() {
			return GetRuleContext<InExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(ModelExpressionParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(ModelExpressionParser.NULL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(ModelExpressionParser.NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public virtual ITerminalNode EQUALS() { return GetToken(ModelExpressionParser.EQUALS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public virtual ITerminalNode NOT_EQUALS() { return GetToken(ModelExpressionParser.NOT_EQUALS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public virtual ITerminalNode LESS_THAN() { return GetToken(ModelExpressionParser.LESS_THAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public virtual ITerminalNode LESS_THAN_OR_EQUAL() { return GetToken(ModelExpressionParser.LESS_THAN_OR_EQUAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public virtual ITerminalNode GREATER_THAN() { return GetToken(ModelExpressionParser.GREATER_THAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public virtual ITerminalNode GREATER_THAN_OR_EQUAL() { return GetToken(ModelExpressionParser.GREATER_THAN_OR_EQUAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIKE() { return GetToken(ModelExpressionParser.LIKE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(ModelExpressionParser.IN, 0); }
		public ComparisonExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_comparisonExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.EnterComparisonExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.ExitComparisonExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IModelExpressionVisitor<TResult> typedVisitor = visitor as IModelExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComparisonExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ComparisonExpressionContext comparisonExpression() {
		ComparisonExpressionContext _localctx = new ComparisonExpressionContext(Context, State);
		EnterRule(_localctx, 8, RULE_comparisonExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 53;
			additiveExpression();
			State = 67;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				{
				State = 54;
				_la = TokenStream.LA(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 32894L) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 55;
				additiveExpression();
				}
				break;
			case 2:
				{
				{
				State = 57;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 56;
					Match(NOT);
					}
				}

				State = 59;
				Match(IN);
				}
				State = 61;
				inExpression();
				}
				break;
			case 3:
				{
				State = 62;
				Match(IS);
				State = 63;
				Match(NULL);
				}
				break;
			case 4:
				{
				State = 64;
				Match(IS);
				State = 65;
				Match(NOT);
				State = 66;
				Match(NULL);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InExpressionContext : ParserRuleContext {
		public InExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inExpression; } }
	 
		public InExpressionContext() { }
		public virtual void CopyFrom(InExpressionContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class InListContext : InExpressionContext {
		public ExpressionContext _expression;
		public IList<ExpressionContext> _expr = new List<ExpressionContext>();
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(ModelExpressionParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(ModelExpressionParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(ModelExpressionParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(ModelExpressionParser.COMMA, i);
		}
		public InListContext(InExpressionContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.EnterInList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.ExitInList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IModelExpressionVisitor<TResult> typedVisitor = visitor as IModelExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InExpressionContext inExpression() {
		InExpressionContext _localctx = new InExpressionContext(Context, State);
		EnterRule(_localctx, 10, RULE_inExpression);
		int _la;
		try {
			_localctx = new InListContext(_localctx);
			EnterOuterAlt(_localctx, 1);
			{
			State = 69;
			Match(LPAREN);
			{
			State = 70;
			((InListContext)_localctx)._expression = expression();
			((InListContext)_localctx)._expr.Add(((InListContext)_localctx)._expression);
			State = 75;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 71;
				Match(COMMA);
				State = 72;
				((InListContext)_localctx)._expression = expression();
				((InListContext)_localctx)._expr.Add(((InListContext)_localctx)._expression);
				}
				}
				State = 77;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
			State = 78;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AdditiveExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public MultiplicativeExpressionContext[] multiplicativeExpression() {
			return GetRuleContexts<MultiplicativeExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MultiplicativeExpressionContext multiplicativeExpression(int i) {
			return GetRuleContext<MultiplicativeExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] PLUS() { return GetTokens(ModelExpressionParser.PLUS); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS(int i) {
			return GetToken(ModelExpressionParser.PLUS, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] MINUS() { return GetTokens(ModelExpressionParser.MINUS); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS(int i) {
			return GetToken(ModelExpressionParser.MINUS, i);
		}
		public AdditiveExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_additiveExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.EnterAdditiveExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.ExitAdditiveExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IModelExpressionVisitor<TResult> typedVisitor = visitor as IModelExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdditiveExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AdditiveExpressionContext additiveExpression() {
		AdditiveExpressionContext _localctx = new AdditiveExpressionContext(Context, State);
		EnterRule(_localctx, 12, RULE_additiveExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 80;
			multiplicativeExpression();
			State = 85;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==PLUS || _la==MINUS) {
				{
				{
				State = 81;
				_la = TokenStream.LA(1);
				if ( !(_la==PLUS || _la==MINUS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 82;
				multiplicativeExpression();
				}
				}
				State = 87;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultiplicativeExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext[] unaryExpression() {
			return GetRuleContexts<UnaryExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnaryExpressionContext unaryExpression(int i) {
			return GetRuleContext<UnaryExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] MULTIPLY() { return GetTokens(ModelExpressionParser.MULTIPLY); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MULTIPLY(int i) {
			return GetToken(ModelExpressionParser.MULTIPLY, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] DIVIDE() { return GetTokens(ModelExpressionParser.DIVIDE); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIVIDE(int i) {
			return GetToken(ModelExpressionParser.DIVIDE, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] MODULO() { return GetTokens(ModelExpressionParser.MODULO); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MODULO(int i) {
			return GetToken(ModelExpressionParser.MODULO, i);
		}
		public MultiplicativeExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiplicativeExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.EnterMultiplicativeExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.ExitMultiplicativeExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IModelExpressionVisitor<TResult> typedVisitor = visitor as IModelExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplicativeExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MultiplicativeExpressionContext multiplicativeExpression() {
		MultiplicativeExpressionContext _localctx = new MultiplicativeExpressionContext(Context, State);
		EnterRule(_localctx, 14, RULE_multiplicativeExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 88;
			unaryExpression();
			State = 93;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & 3584L) != 0)) {
				{
				{
				State = 89;
				_la = TokenStream.LA(1);
				if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 3584L) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 90;
				unaryExpression();
				}
				}
				State = 95;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnaryExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public virtual PrimaryExpressionContext primaryExpression() {
			return GetRuleContext<PrimaryExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public virtual ITerminalNode PLUS() { return GetToken(ModelExpressionParser.PLUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public virtual ITerminalNode MINUS() { return GetToken(ModelExpressionParser.MINUS, 0); }
		public UnaryExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unaryExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.EnterUnaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.ExitUnaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IModelExpressionVisitor<TResult> typedVisitor = visitor as IModelExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnaryExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnaryExpressionContext unaryExpression() {
		UnaryExpressionContext _localctx = new UnaryExpressionContext(Context, State);
		EnterRule(_localctx, 16, RULE_unaryExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 97;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PLUS || _la==MINUS) {
				{
				State = 96;
				_la = TokenStream.LA(1);
				if ( !(_la==PLUS || _la==MINUS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 99;
			primaryExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrimaryExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(ModelExpressionParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(ModelExpressionParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ColumnReferenceContext columnReference() {
			return GetRuleContext<ColumnReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		public PrimaryExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_primaryExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.EnterPrimaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.ExitPrimaryExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IModelExpressionVisitor<TResult> typedVisitor = visitor as IModelExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimaryExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrimaryExpressionContext primaryExpression() {
		PrimaryExpressionContext _localctx = new PrimaryExpressionContext(Context, State);
		EnterRule(_localctx, 18, RULE_primaryExpression);
		try {
			State = 108;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
				EnterOuterAlt(_localctx, 1);
				{
				State = 101;
				Match(LPAREN);
				State = 102;
				expression();
				State = 103;
				Match(RPAREN);
				}
				break;
			case CONVERT:
			case LEN:
			case ISNULL:
			case IIF:
			case TRIM:
			case SUBSTRING:
			case SUM:
			case AVG:
			case MIN:
			case MAX:
			case COUNT:
			case STDEV:
			case VAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 105;
				functionCall();
				}
				break;
			case PARENT:
			case CHILD:
			case BACKTICK:
			case IDENTIFIER:
			case BRACKETED_IDENTIFIER:
				EnterOuterAlt(_localctx, 3);
				{
				State = 106;
				columnReference();
				}
				break;
			case STRING_LITERAL:
			case DATE_LITERAL:
			case INTEGER_LITERAL:
			case DECIMAL_LITERAL:
			case BOOLEAN_LITERAL:
			case NULL_LITERAL:
				EnterOuterAlt(_localctx, 4);
				{
				State = 107;
				literal();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionCallContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public virtual FunctionNameContext functionName() {
			return GetRuleContext<FunctionNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(ModelExpressionParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(ModelExpressionParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public virtual ArgumentListContext argumentList() {
			return GetRuleContext<ArgumentListContext>(0);
		}
		public FunctionCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionCall; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.EnterFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.ExitFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IModelExpressionVisitor<TResult> typedVisitor = visitor as IModelExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionCallContext functionCall() {
		FunctionCallContext _localctx = new FunctionCallContext(Context, State);
		EnterRule(_localctx, 20, RULE_functionCall);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 110;
			functionName();
			State = 111;
			Match(LPAREN);
			State = 113;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 1121798212960640L) != 0)) {
				{
				State = 112;
				argumentList();
				}
			}

			State = 115;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONVERT() { return GetToken(ModelExpressionParser.CONVERT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEN() { return GetToken(ModelExpressionParser.LEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ISNULL() { return GetToken(ModelExpressionParser.ISNULL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IIF() { return GetToken(ModelExpressionParser.IIF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRIM() { return GetToken(ModelExpressionParser.TRIM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUBSTRING() { return GetToken(ModelExpressionParser.SUBSTRING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUM() { return GetToken(ModelExpressionParser.SUM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AVG() { return GetToken(ModelExpressionParser.AVG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MIN() { return GetToken(ModelExpressionParser.MIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAX() { return GetToken(ModelExpressionParser.MAX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COUNT() { return GetToken(ModelExpressionParser.COUNT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STDEV() { return GetToken(ModelExpressionParser.STDEV, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VAR() { return GetToken(ModelExpressionParser.VAR, 0); }
		public FunctionNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.EnterFunctionName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.ExitFunctionName(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IModelExpressionVisitor<TResult> typedVisitor = visitor as IModelExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionNameContext functionName() {
		FunctionNameContext _localctx = new FunctionNameContext(Context, State);
		EnterRule(_localctx, 22, RULE_functionName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 117;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 1073610752L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public virtual ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(ModelExpressionParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(ModelExpressionParser.COMMA, i);
		}
		public ArgumentListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argumentList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.EnterArgumentList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.ExitArgumentList(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IModelExpressionVisitor<TResult> typedVisitor = visitor as IModelExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgumentList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentListContext argumentList() {
		ArgumentListContext _localctx = new ArgumentListContext(Context, State);
		EnterRule(_localctx, 24, RULE_argumentList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 119;
			expression();
			State = 124;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 120;
				Match(COMMA);
				State = 121;
				expression();
				}
				}
				State = 126;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ColumnReferenceContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BRACKETED_IDENTIFIER() { return GetToken(ModelExpressionParser.BRACKETED_IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] BACKTICK() { return GetTokens(ModelExpressionParser.BACKTICK); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BACKTICK(int i) {
			return GetToken(ModelExpressionParser.BACKTICK, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] IDENTIFIER() { return GetTokens(ModelExpressionParser.IDENTIFIER); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER(int i) {
			return GetToken(ModelExpressionParser.IDENTIFIER, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARENT() { return GetToken(ModelExpressionParser.PARENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(ModelExpressionParser.DOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHILD() { return GetToken(ModelExpressionParser.CHILD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(ModelExpressionParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(ModelExpressionParser.RPAREN, 0); }
		public ColumnReferenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_columnReference; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.EnterColumnReference(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.ExitColumnReference(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IModelExpressionVisitor<TResult> typedVisitor = visitor as IModelExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitColumnReference(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ColumnReferenceContext columnReference() {
		ColumnReferenceContext _localctx = new ColumnReferenceContext(Context, State);
		EnterRule(_localctx, 26, RULE_columnReference);
		try {
			State = 150;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,12,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 127;
				Match(BRACKETED_IDENTIFIER);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 128;
				Match(BACKTICK);
				State = 129;
				Match(IDENTIFIER);
				State = 130;
				Match(BACKTICK);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 131;
				Match(IDENTIFIER);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 132;
				Match(PARENT);
				State = 133;
				Match(DOT);
				State = 134;
				Match(IDENTIFIER);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 135;
				Match(CHILD);
				State = 136;
				Match(DOT);
				State = 137;
				Match(IDENTIFIER);
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 138;
				Match(PARENT);
				State = 139;
				Match(LPAREN);
				State = 140;
				Match(IDENTIFIER);
				State = 141;
				Match(RPAREN);
				State = 142;
				Match(DOT);
				State = 143;
				Match(IDENTIFIER);
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 144;
				Match(CHILD);
				State = 145;
				Match(LPAREN);
				State = 146;
				Match(IDENTIFIER);
				State = 147;
				Match(RPAREN);
				State = 148;
				Match(DOT);
				State = 149;
				Match(IDENTIFIER);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STRING_LITERAL() { return GetToken(ModelExpressionParser.STRING_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER_LITERAL() { return GetToken(ModelExpressionParser.INTEGER_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DECIMAL_LITERAL() { return GetToken(ModelExpressionParser.DECIMAL_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BOOLEAN_LITERAL() { return GetToken(ModelExpressionParser.BOOLEAN_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATE_LITERAL() { return GetToken(ModelExpressionParser.DATE_LITERAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL_LITERAL() { return GetToken(ModelExpressionParser.NULL_LITERAL, 0); }
		public LiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.EnterLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			IModelExpressionListener typedListener = listener as IModelExpressionListener;
			if (typedListener != null) typedListener.ExitLiteral(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IModelExpressionVisitor<TResult> typedVisitor = visitor as IModelExpressionVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralContext literal() {
		LiteralContext _localctx = new LiteralContext(Context, State);
		EnterRule(_localctx, 28, RULE_literal);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 152;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 277076930199552L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static int[] _serializedATN = {
		4,1,50,155,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		1,0,1,0,1,1,1,1,1,1,5,1,36,8,1,10,1,12,1,39,9,1,1,2,1,2,1,2,5,2,44,8,2,
		10,2,12,2,47,9,2,1,3,3,3,50,8,3,1,3,1,3,1,4,1,4,1,4,1,4,3,4,58,8,4,1,4,
		1,4,1,4,1,4,1,4,1,4,1,4,1,4,3,4,68,8,4,1,5,1,5,1,5,1,5,5,5,74,8,5,10,5,
		12,5,77,9,5,1,5,1,5,1,6,1,6,1,6,5,6,84,8,6,10,6,12,6,87,9,6,1,7,1,7,1,
		7,5,7,92,8,7,10,7,12,7,95,9,7,1,8,3,8,98,8,8,1,8,1,8,1,9,1,9,1,9,1,9,1,
		9,1,9,1,9,3,9,109,8,9,1,10,1,10,1,10,3,10,114,8,10,1,10,1,10,1,11,1,11,
		1,12,1,12,1,12,5,12,123,8,12,10,12,12,12,126,9,12,1,13,1,13,1,13,1,13,
		1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,
		1,13,1,13,1,13,1,13,1,13,3,13,151,8,13,1,14,1,14,1,14,0,0,15,0,2,4,6,8,
		10,12,14,16,18,20,22,24,26,28,0,5,2,0,1,6,15,15,1,0,7,8,1,0,9,11,1,0,17,
		29,1,0,42,47,162,0,30,1,0,0,0,2,32,1,0,0,0,4,40,1,0,0,0,6,49,1,0,0,0,8,
		53,1,0,0,0,10,69,1,0,0,0,12,80,1,0,0,0,14,88,1,0,0,0,16,97,1,0,0,0,18,
		108,1,0,0,0,20,110,1,0,0,0,22,117,1,0,0,0,24,119,1,0,0,0,26,150,1,0,0,
		0,28,152,1,0,0,0,30,31,3,2,1,0,31,1,1,0,0,0,32,37,3,4,2,0,33,34,5,13,0,
		0,34,36,3,4,2,0,35,33,1,0,0,0,36,39,1,0,0,0,37,35,1,0,0,0,37,38,1,0,0,
		0,38,3,1,0,0,0,39,37,1,0,0,0,40,45,3,6,3,0,41,42,5,12,0,0,42,44,3,6,3,
		0,43,41,1,0,0,0,44,47,1,0,0,0,45,43,1,0,0,0,45,46,1,0,0,0,46,5,1,0,0,0,
		47,45,1,0,0,0,48,50,5,14,0,0,49,48,1,0,0,0,49,50,1,0,0,0,50,51,1,0,0,0,
		51,52,3,8,4,0,52,7,1,0,0,0,53,67,3,12,6,0,54,55,7,0,0,0,55,68,3,12,6,0,
		56,58,5,14,0,0,57,56,1,0,0,0,57,58,1,0,0,0,58,59,1,0,0,0,59,60,5,16,0,
		0,60,61,1,0,0,0,61,68,3,10,5,0,62,63,5,33,0,0,63,68,5,32,0,0,64,65,5,33,
		0,0,65,66,5,14,0,0,66,68,5,32,0,0,67,54,1,0,0,0,67,57,1,0,0,0,67,62,1,
		0,0,0,67,64,1,0,0,0,67,68,1,0,0,0,68,9,1,0,0,0,69,70,5,34,0,0,70,75,3,
		0,0,0,71,72,5,40,0,0,72,74,3,0,0,0,73,71,1,0,0,0,74,77,1,0,0,0,75,73,1,
		0,0,0,75,76,1,0,0,0,76,78,1,0,0,0,77,75,1,0,0,0,78,79,5,35,0,0,79,11,1,
		0,0,0,80,85,3,14,7,0,81,82,7,1,0,0,82,84,3,14,7,0,83,81,1,0,0,0,84,87,
		1,0,0,0,85,83,1,0,0,0,85,86,1,0,0,0,86,13,1,0,0,0,87,85,1,0,0,0,88,93,
		3,16,8,0,89,90,7,2,0,0,90,92,3,16,8,0,91,89,1,0,0,0,92,95,1,0,0,0,93,91,
		1,0,0,0,93,94,1,0,0,0,94,15,1,0,0,0,95,93,1,0,0,0,96,98,7,1,0,0,97,96,
		1,0,0,0,97,98,1,0,0,0,98,99,1,0,0,0,99,100,3,18,9,0,100,17,1,0,0,0,101,
		102,5,34,0,0,102,103,3,0,0,0,103,104,5,35,0,0,104,109,1,0,0,0,105,109,
		3,20,10,0,106,109,3,26,13,0,107,109,3,28,14,0,108,101,1,0,0,0,108,105,
		1,0,0,0,108,106,1,0,0,0,108,107,1,0,0,0,109,19,1,0,0,0,110,111,3,22,11,
		0,111,113,5,34,0,0,112,114,3,24,12,0,113,112,1,0,0,0,113,114,1,0,0,0,114,
		115,1,0,0,0,115,116,5,35,0,0,116,21,1,0,0,0,117,118,7,3,0,0,118,23,1,0,
		0,0,119,124,3,0,0,0,120,121,5,40,0,0,121,123,3,0,0,0,122,120,1,0,0,0,123,
		126,1,0,0,0,124,122,1,0,0,0,124,125,1,0,0,0,125,25,1,0,0,0,126,124,1,0,
		0,0,127,151,5,49,0,0,128,129,5,38,0,0,129,130,5,48,0,0,130,151,5,38,0,
		0,131,151,5,48,0,0,132,133,5,30,0,0,133,134,5,39,0,0,134,151,5,48,0,0,
		135,136,5,31,0,0,136,137,5,39,0,0,137,151,5,48,0,0,138,139,5,30,0,0,139,
		140,5,34,0,0,140,141,5,48,0,0,141,142,5,35,0,0,142,143,5,39,0,0,143,151,
		5,48,0,0,144,145,5,31,0,0,145,146,5,34,0,0,146,147,5,48,0,0,147,148,5,
		35,0,0,148,149,5,39,0,0,149,151,5,48,0,0,150,127,1,0,0,0,150,128,1,0,0,
		0,150,131,1,0,0,0,150,132,1,0,0,0,150,135,1,0,0,0,150,138,1,0,0,0,150,
		144,1,0,0,0,151,27,1,0,0,0,152,153,7,4,0,0,153,29,1,0,0,0,13,37,45,49,
		57,67,75,85,93,97,108,113,124,150
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
